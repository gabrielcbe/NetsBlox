<blocks app="NetsBlox 1.14.0, http://netsblox.org" version="1.14.0"><block-definition collabId="item_0_128" s="Speck32/64 encrypt text %&apos;text&apos; key words %&apos;keywords&apos;" type="reporter" category="custom"><header></header><code></code><inputs><input type="%txt"></input><input type="%l"></input></inputs><script><block collabId="item_0_121" s="doReport"><block collabId="item_0_120" s="evaluate"><block collabId="item_0_119" s="reportJSFunction"><list><l>Speck</l><l>text</l><l>keywordsList</l></list><l>s32 = new Speck();&#xD;var keywords = keywordsList.contents.map(it =&gt; parseInt(it));&#xD;var encText =  s32.encryptAscii(text, keywords);&#xD;return encText;</l></block><list><custom-block collabId="item_0_112" s="speck32/64 loader"></custom-block><block collabId="item_0_111" var="text"/><block collabId="item_0_110" var="keywords"/></list></block></block></script></block-definition><block-definition collabId="item_0_109" s="speck32/64 loader" type="reporter" category="other"><header></header><code></code><inputs></inputs><script><block collabId="item_0_104" s="doReport"><block collabId="item_0_103" s="evaluate"><block collabId="item_0_102" s="reportJSFunction"><list><l></l></list><l>require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&amp;&amp;require;if(!f&amp;&amp;c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module &apos;"+i+"&apos;");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&amp;&amp;require,i=0;i&lt;t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){&#xD;const { dec2Bin, printBinary, ensureNBits, asciiToBits, chopString, binaryToAsciiChar } = require(&apos;./utils&apos;);&#xD;&#xD;/*&#xD;* fiestel block encryption helper&#xD;* relies heavily on javascripts charCodeAt and fromCharCode.&#xD;* assumes 8bit ascii alphabet&#xD;*/&#xD;class BlockCipher {&#xD;  /*&#xD;  * @param {Number} n word size in bits&#xD;  * @param {Number} m number of keywords&#xD;  */&#xD;  constructor(n, m, numRounds) {&#xD;    if (!n || !m || !numRounds) throw new Error(&apos;missing initialization parameters&apos;);&#xD;    console.log(`creating block cipher with block size: ${2*n} key size: ${m*n}`);&#xD;    this.m = m;&#xD;    this.n = n;&#xD;    this.numRounds = numRounds;&#xD;    this.MAX_KEY = Math.pow(2, m * n);&#xD;    this.MAX_WORD = Math.pow(2, n);&#xD;    this.ALPHABET_SIZE = 8;&#xD;  }&#xD;&#xD;  _checkKeyWords(keyWords) {&#xD;    if (!Array.isArray(keyWords) || keyWords.length !== this.m) throw new Error(&apos;bad key words&apos;);&#xD;    keyWords.forEach(key =&gt; {&#xD;      if (isNaN(key) || key &gt; this.MAX_WORD) throw new Error(&apos;bad key word&apos;, key);&#xD;    })&#xD;  }&#xD;&#xD;  /*&#xD;  * @param {Array&lt;Number&gt;} keyWords a list of key words containing numbers up to word size&#xD;  * @returns {Array&lt;Number&gt;} round keys: a list of round keys&#xD;  */&#xD;  _expandKey(keyWords) {&#xD;    this._checkKeyWords(keyWords);&#xD;    // override&#xD;  }&#xD;&#xD;  /*&#xD;  * @param {Array&lt;Number&gt;} words a list of 2 words (a block)&#xD;  * @param {Array&lt;Number&gt;} rKeys: a list of round keys&#xD;  */&#xD;  _encrypt(words, rKeys) {&#xD;    // override&#xD;    throw new Error(&apos;not implemented&apos;);&#xD;  }&#xD;&#xD;  /*&#xD;  * @param {Array&lt;Number&gt;} words a list of 2 words (a block)&#xD;  * @param {Array&lt;Number&gt;} rKeys: a list of round keys&#xD;  */&#xD;  _decrypt(words, rKeys) {&#xD;    // override&#xD;    throw new Error(&apos;not implemented&apos;);&#xD;  }&#xD;&#xD;  /*&#xD;  * converts text to word sized integer blocks&#xD;  * @param {string} text ascii text to encrypt (8bit encoded)&#xD;  */&#xD;  _textToNumericBlocks(text) {&#xD;    // prepare the text&#xD;    let bits = asciiToBits(text);&#xD;    // console.log(bits);&#xD;    let inputWords = chopString(bits, this.n)&#xD;      .map(word =&gt; parseInt(word, 2));&#xD;    // console.log(&apos;input words&apos;, inputWords);&#xD;&#xD;    // account for odd number of words&#xD;    if (inputWords.length % 2 !== 0) inputWords.push(0);&#xD;&#xD;    let blocks = []&#xD;    while (inputWords.length) {&#xD;      blocks.push([inputWords.shift(), inputWords.shift()]);&#xD;    }&#xD;    return blocks;&#xD;  }&#xD;&#xD;  /*&#xD;  * converts word sized integer blocks to text&#xD;  * WARN drops null characters \u0000&#xD;  * @param {Array&lt;Number&gt;} encWords converts a list of word integers into text&#xD;  * @param {Boolean=} removeNulls determines if the null characters should be removed in the process&#xD;  */&#xD;  _numericBlocksToText(intWords, removeNulls=false) {&#xD;    const NULL_CHAR = new Array(this.ALPHABET_SIZE).fill(0).join(&apos;&apos;); // initially generated by padding small numbers&#xD;    // ensure each word is alphabet size&#xD;    let bitsStr =  intWords&#xD;      .map(w =&gt; dec2Bin(w)) // convert to bin string repr&#xD;      .map(w =&gt; ensureNBits(w, this.n))&#xD;      .join(&apos;&apos;);&#xD;&#xD;    // convert it back to ascii&#xD;    console.assert(bitsStr.length % this.ALPHABET_SIZE === 0);&#xD;    let charBitBuckets =  chopString(bitsStr, this.ALPHABET_SIZE);&#xD;    if (removeNulls) charBitBuckets = charBitBuckets.filter(charBits =&gt; charBits !== NULL_CHAR);&#xD;&#xD;    return charBitBuckets.map(binaryChar =&gt; binaryToAsciiChar(binaryChar))&#xD;      .join(&apos;&apos;);&#xD;  }&#xD;&#xD;  /*&#xD;  * @param {string} text ascii text to encrypt (8bit encoded)&#xD;  * @param {Array&lt;Number&gt;} keyWords a list of key words containing numbers up to word size&#xD;  */&#xD;  encryptAscii(text, keyWords) {&#xD;    if (text === undefined) throw new Error(&apos;bad input&apos;);&#xD;&#xD;    // prepare the round keys&#xD;    let roundKeys = this._expandKey(keyWords);&#xD;    // console.log(roundKeys);&#xD;&#xD;    let encWords = [];&#xD;    let blocks = this._textToNumericBlocks(text);&#xD;    blocks.forEach(block =&gt; {&#xD;      const [encX, encY] = this._encrypt(block, roundKeys);&#xD;      if (encX &gt; this.MAX_WORD || encY &gt; this.MAX_WORD) throw new Error(&apos;encryptiong returned too big a number&apos;);&#xD;      encWords.push(encX, encY);&#xD;    })&#xD;&#xD;    return this._numericBlocksToText(encWords);&#xD;  }&#xD;&#xD;  /*&#xD;  * @param {string} text ascii text to encrypt (8bit encoded)&#xD;  * @param {Array&lt;Number&gt;} keyWords a list of key words containing numbers each up to word size&#xD;  */&#xD;  decryptAscii(text, keyWords) {&#xD;    if (text === undefined) throw new Error(&apos;bad input&apos;);&#xD;&#xD;    // prepare the round keys&#xD;    let roundKeys = this._expandKey(keyWords);&#xD;    // console.log(roundKeys);&#xD;&#xD;    let encWords = [];&#xD;    let blocks = this._textToNumericBlocks(text);&#xD;    blocks.forEach(block =&gt; {&#xD;      const [decX, decY] = this._decrypt(block, roundKeys);&#xD;      if (decX &gt; this.MAX_WORD || decY &gt; this.MAX_WORD) throw new Error(&apos;encryptiong returned too big a number&apos;);&#xD;      encWords.push(decX, decY);&#xD;    })&#xD;    // console.log(&apos;enc words&apos;, encWords);&#xD;&#xD;    return this._numericBlocksToText(encWords, true);&#xD;  }&#xD;}&#xD;&#xD;module.exports = BlockCipher;&#xD;&#xD;},{"./utils":2}],2:[function(require,module,exports){&#xD;// js int length for bitwise operations (in form of two&apos;s complement)&#xD;const JSINTLENGTH = 32;&#xD;const ASCII_SIZE = 8;&#xD;&#xD;// WARN positive dec&#xD;let dec2Bin = dec =&gt; {&#xD;  return (dec &gt;&gt;&gt; 0).toString(2);&#xD;}&#xD;&#xD;// ensure binary string is n bits&#xD;let ensureNBits = (str, n) =&gt; {&#xD;  diff = n - str.length;&#xD;  if (diff &lt; 0) throw new Error(`input binary out of the defined alphabet range ${str.length} vs ${n}`);&#xD;  console.assert(diff &gt;= 0);&#xD;  if (diff &gt; 0) {&#xD;    let pad = &apos;&apos;;&#xD;    for (let i=0; i &lt; diff; i++) {&#xD;      pad += &apos;0&apos;;&#xD;    }&#xD;    str = pad + str;&#xD;  }&#xD;  return str;&#xD;};&#xD;&#xD;&#xD;// padded string repr of num&#xD;let asciiCharToBinary =  c =&gt; {&#xD;  let decNum = c.charCodeAt(0); // CHECK UTF16 but also ASCII ?!&#xD;  let numStr = dec2Bin(decNum);&#xD;  numStr = ensureNBits(numStr, ASCII_SIZE);&#xD;  return numStr;&#xD;};&#xD;&#xD;let binaryToAsciiChar =  binaryStr =&gt; {&#xD;  if (binaryStr.length !== ASCII_SIZE) throw new Error(`input has to be ${ASCII_SIZE} bits`);&#xD;  let c = String.fromCharCode(parseInt(binaryStr, 2));&#xD;  return c;&#xD;};&#xD;&#xD;&#xD;let printBinary = int =&gt; {&#xD;  let str = int.toString(2);&#xD;  return str;&#xD;};&#xD;&#xD;let lcs = (xInt, nBits) =&gt; {&#xD;  if (nBits === undefined) throw new Error(&apos;missing input: number of bits to shift is required&apos;);&#xD;  let res = (xInt &lt;&lt; nBits | xInt &gt;&gt;&gt; JSINTLENGTH-nBits)&#xD;  return res;&#xD;};&#xD;&#xD;let rcs = (xInt, nBits) =&gt; {&#xD;  if (nBits === undefined) throw new Error(&apos;missing input: number of bits to shift is required&apos;);&#xD;  let res = (xInt &lt;&lt; JSINTLENGTH-nBits | xInt &gt;&gt;&gt; nBits)&#xD;  return res;&#xD;};&#xD;&#xD;let lcsn = (xInt, nBits, unsignedBitCount) =&gt; {&#xD;  if (nBits === undefined) throw new Error(&apos;missing input: number of bits to shift is required&apos;);&#xD;  if (unsignedBitCount &gt; 32 || unsignedBitCount &lt; 1) throw new Error(&apos;bad number size&apos;)&#xD;  let res = (xInt &lt;&lt; nBits | xInt &gt;&gt;&gt; unsignedBitCount-nBits) &amp; (Math.pow(2, unsignedBitCount) - 1)&#xD;  return res;&#xD;};&#xD;&#xD;let rcsn = (xInt, nBits, unsignedBitCount) =&gt; {&#xD;  if (nBits === undefined) throw new Error(&apos;missing input: number of bits to shift is required&apos;);&#xD;  if (unsignedBitCount &gt; 32 || unsignedBitCount &lt; 1) throw new Error(&apos;bad number size&apos;)&#xD;  let res = (xInt &lt;&lt; unsignedBitCount-nBits | xInt &gt;&gt;&gt; nBits) &amp; (Math.pow(2, unsignedBitCount) - 1)&#xD;  return res;&#xD;};&#xD;&#xD;// FIXME there should be a way of avoiding strings..&#xD;let asciiToBits = str =&gt; {&#xD;  let bitRep = &apos;&apos;;&#xD;  for (var n = 0, l = str.length; n &lt; l; n ++)&#xD;  {&#xD;    bitRep += asciiCharToBinary(str[n]);&#xD;  }&#xD;  return bitRep;&#xD;};&#xD;&#xD;let chopString = (str, blockSize) =&gt; {&#xD;  let re = new RegExp(`.{1,${blockSize}}`, &apos;g&apos;);&#xD;  return str.match(re);&#xD;};&#xD;&#xD;/**&#xD; * Computes x mod n&#xD; * x arbitrary integer&#xD; * n natural number&#xD; */&#xD;const mod = (x, n) =&gt; ((x % n) + n) % n;&#xD;// const mod = (x, n) =&gt; x &amp; n;&#xD;&#xD;let moduloAdd = (a, b, base) =&gt; {&#xD;  return mod((a + b), base);&#xD;}&#xD;&#xD;let moduloSub = (a, b, base) =&gt; {&#xD;  return mod((a - b), base);&#xD;}&#xD;&#xD;module.exports = {&#xD;  lcs,&#xD;  rcs,&#xD;  lcsn,&#xD;  rcsn,&#xD;  moduloAdd,&#xD;  moduloSub,&#xD;  lcs16: (xInt, nBits) =&gt; lcsn(xInt, nBits, 16),&#xD;  rcs16: (xInt, nBits) =&gt; rcsn(xInt, nBits, 16),&#xD;  printBinary,&#xD;  asciiToBits,&#xD;  asciiCharToBinary,&#xD;  binaryToAsciiChar,&#xD;  ensureNBits,&#xD;  dec2Bin,&#xD;  chopString,&#xD;  mod,&#xD;}&#xD;&#xD;},{}],"speck3264":[function(require,module,exports){&#xD;const { printBinary, mod, lcsn, rcsn, asciiToBits, chopString } = require(&apos;../utils&apos;),&#xD;  BlockCipher = require(&apos;../blockCipher&apos;);&#xD;&#xD;class SpeckNative32 extends BlockCipher {&#xD;  constructor() {&#xD;    super(16, 4, 22);&#xD;    this.alpha = 7;&#xD;    this.beta = 2;&#xD;  }&#xD;&#xD;  _expandKey(keyWords) {&#xD;    super._expandKey(keyWords);&#xD;    let rKeys = [];&#xD;    // build the initial L and K CHECK&#xD;    const m = this.m;&#xD;    const sixteenOnes = Math.pow(2,16) - 1;&#xD;&#xD;    let key = [...keyWords]; // shallow copy to dereference&#xD;    var k = key[3];&#xD;    for (var i = 0, j; i &lt; this.numRounds; ++i) {&#xD;        rKeys[i] = k;&#xD;        j = 2 - i % 3;&#xD;        key[j] = rcsn(key[j], 7, 16) + k &amp; sixteenOnes ^ i;&#xD;        k = lcsn(k, 2, 16) ^ key[j];&#xD;    }&#xD;&#xD;    return rKeys;&#xD;  }&#xD;&#xD;  _round(x, y, rKey) {&#xD;    // calc x&#xD;    let leftTerm = mod(rcsn(x, this.alpha, 16) + y, Math.pow(2, this.n)); // modulo addition&#xD;    // CHECK override x here?&#xD;    x = leftTerm ^ rKey;&#xD;    y = lcsn(y, this.beta, 16) ^ x;&#xD;&#xD;    return [x, y];&#xD;  }&#xD;&#xD;  // inverse round&#xD;  _roundI(x, y, rKey) {&#xD;    y = rcsn(x ^ y, this.beta, 16);&#xD;    let leftT = mod((x ^ rKey) - y, Math.pow(2, this.n)); // modulo subtraction&#xD;    x = lcsn(leftT, this.alpha, 16);&#xD;    return [x, y];&#xD;  }&#xD;&#xD;  // input: 2 words (a block) and a list of round keys&#xD;  _encrypt(words, rKeys) {&#xD;    // console.log(&apos;input words to encrypt&apos;, words);&#xD;    let [x, y] = words;&#xD;    for (let i=0; i&lt;this.numRounds; i++) {&#xD;      [x, y] = this._round(x, y, rKeys[i]);&#xD;    }&#xD;    return [x, y];&#xD;  }&#xD;&#xD;  _decrypt(words, rKeys) {&#xD;    // console.log(&apos;input words to decrypt&apos;, words);&#xD;    let [x, y] = words;&#xD;    for (let i=this.numRounds-1; i &gt;= 0; i--) {&#xD;      [x, y] = this._roundI(x, y, rKeys[i]);&#xD;    }&#xD;    return [x, y];&#xD;  }&#xD;}&#xD;&#xD;module.exports = SpeckNative32;&#xD;&#xD;},{"../blockCipher":1,"../utils":2}]},{},[]);&#xD;&#xD;return new require(&apos;speck3264&apos;);&#xD;</l></block><list></list></block></block></script></block-definition><block-definition collabId="item_0_97" s="Speck32/64 decrypt text %&apos;text&apos; keywords %&apos;keywords&apos;" type="reporter" category="other"><header></header><code></code><inputs><input type="%txt"></input><input type="%l"></input></inputs><script><block collabId="item_0_90" s="doReport"><block collabId="item_0_89" s="evaluate"><block collabId="item_0_88" s="reportJSFunction"><list><l>Speck</l><l>text</l><l>keywordsList</l></list><l>s32 = new Speck();&#xD;var keywords = keywordsList.contents.map(it =&gt; parseInt(it));&#xD;var encText =  s32.decryptAscii(text, keywords);&#xD;return encText;</l></block><list><custom-block collabId="item_0_81" s="speck32/64 loader"></custom-block><block collabId="item_0_80" var="text"/><block collabId="item_0_79" var="keywords"/></list></block></block></script></block-definition><block-definition collabId="item_0_78" s="Speck32/64 expand keywords %&apos;keywords&apos;" type="reporter" category="other"><header></header><code></code><inputs><input type="%l"></input></inputs><script><block collabId="item_0_72" s="doReport"><block collabId="item_0_71" s="evaluate"><block collabId="item_0_70" s="reportJSFunction"><list><l>Speck</l><l>keywordsList</l></list><l>s32 = new Speck();&#xD;var keywords = keywordsList.contents.map(it =&gt; parseInt(it));&#xD;var roundKeys =  s32._expandKey(keywords);&#xD;return new List(roundKeys);</l></block><list><custom-block collabId="item_0_64" s="speck32/64 loader"></custom-block><block collabId="item_0_63" var="keywords"/></list></block></block></script></block-definition><block-definition collabId="item_0_62" s="Speck32/64 inverse round function L %&apos;left&apos; R %&apos;right&apos; roundKey %&apos;key&apos;" type="reporter" category="custom"><header></header><code></code><inputs><input type="%n"></input><input type="%n"></input><input type="%n"></input></inputs><script><block collabId="item_0_54" s="doReport"><block collabId="item_0_53" s="evaluate"><block collabId="item_0_52" s="reportJSFunction"><list><l>Speck</l><l>roundKey</l><l>left</l><l>right</l></list><l>s32 = new Speck();&#xD;var key = parseInt(roundKey);&#xD;var l = parseInt(left);&#xD;var r = parseInt(right);&#xD;console.log(l, r, key);&#xD;var output =  s32._roundI(l, r, key);&#xD;return new List(output);</l></block><list><custom-block collabId="item_0_44" s="speck32/64 loader"></custom-block><block collabId="item_0_43" var="key"/><block collabId="item_0_42" var="left"/><block collabId="item_0_41" var="right"/></list></block></block></script></block-definition><block-definition collabId="item_0_40" s="Speck32/64 decrypt block %&apos;block&apos; roundkeys %&apos;rkeys&apos;" type="reporter" category="custom"><header></header><code></code><inputs><input type="%l"></input><input type="%l"></input></inputs><script><block collabId="item_0_33" s="doReport"><block collabId="item_0_32" s="evaluate"><block collabId="item_0_31" s="reportJSFunction"><list><l>Speck</l><l>block</l><l>rKeys</l></list><l>s32 = new Speck();&#xD;console.log(rKeys);&#xD;var keys = rKeys.contents.map(it =&gt; parseInt(it));&#xD;var words = block.contents.map(it =&gt; parseInt(it));&#xD;console.log(words, keys);&#xD;var output =  s32._decrypt(words, keys);&#xD;return new List(output);</l></block><list><custom-block collabId="item_0_24" s="speck32/64 loader"></custom-block><block collabId="item_0_23" var="block"/><block collabId="item_0_22" var="rkeys"/></list></block></block></script></block-definition><block-definition collabId="item_0_21" s="Speck32/64 round function L %&apos;left&apos; R %&apos;right&apos; roundKey %&apos;key&apos;" type="reporter" category="custom"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input><input type="%s"></input></inputs><script><block collabId="item_0_13" s="doReport"><block collabId="item_0_12" s="evaluate"><block collabId="item_0_11" s="reportJSFunction"><list><l>Speck</l><l>roundKey</l><l>left</l><l>right</l></list><l>s32 = new Speck();&#xD;var key = parseInt(roundKey);&#xD;var l = parseInt(left);&#xD;var r = parseInt(right);&#xD;console.log(l, r, key);&#xD;var output =  s32._round(l, r, key);&#xD;return new List(output);</l></block><list><custom-block collabId="item_0_3" s="speck32/64 loader"></custom-block><block collabId="item_0_2" var="key"/><block collabId="item_0_1" var="left"/><block collabId="item_0" var="right"/></list></block></block></script></block-definition><block-definition collabId="item_1_441" s="encrypt %&apos;text&apos; %&apos;shift&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block collabId="item_1_434" s="doDeclareVariables"><list><l>num</l></list></block><block collabId="item_1_431" s="doWarp"><script><block collabId="item_1_429" s="doSetVar"><l>text</l><custom-block collabId="item_1_427" s="word $arrowRight list %txt"><block collabId="item_1_426" var="text"/></custom-block></block><block collabId="item_1_425" s="doSetVar"><l>num</l><custom-block collabId="item_1_423" s="map %repRing over %mult%l"><block collabId="item_1_422" s="reifyReporter"><autolambda><block collabId="item_1_420" s="reportUnicode"><l></l></block></autolambda><list></list></block><list><block collabId="item_1_416" var="text"/></list></custom-block></block><block collabId="item_1_415" s="doSetVar"><l>num</l><custom-block collabId="item_1_413" s="map %repRing over %mult%l"><block collabId="item_1_412" s="reifyReporter"><autolambda><block collabId="item_1_410" s="reportSum"><block collabId="item_1_409" s="reportModulus"><block collabId="item_1_408" s="reportSum"><l></l><block collabId="item_1_406" s="reportDifference"><block collabId="item_1_405" var="shift"/><l>32</l></block></block><l>95</l></block><l>32</l></block></autolambda><list></list></block><list><block collabId="item_1_399" var="num"/></list></custom-block></block><block collabId="item_1_398" s="doSetVar"><l>text</l><custom-block collabId="item_1_396" s="list $arrowRight word %l"><custom-block collabId="item_1_395" s="map %repRing over %mult%l"><block collabId="item_1_394" s="reifyReporter"><autolambda><block collabId="item_1_392" s="reportUnicodeAsLetter"><l></l></block></autolambda><list></list></block><list><block collabId="item_1_388" var="num"/></list></custom-block></custom-block></block><block collabId="item_1_387" s="doReport"><block collabId="item_1_386" var="text"/></block></script></block></script></block-definition><block-definition collabId="item_1_385" s="decrypt %&apos;encoded&apos; %&apos;shift&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block collabId="item_1_378" s="doReport"><custom-block collabId="item_1_377" s="encrypt %s %s"><block collabId="item_1_376" var="encoded"/><block collabId="item_1_375" s="reportDifference"><l>0</l><block collabId="item_1_373" var="shift"/></block></custom-block></block></script></block-definition><block-definition collabId="item_1_372" s="encrypt++ %&apos;text&apos; %&apos;shift list&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block collabId="item_1_365" s="doDeclareVariables"><list><l>num</l><l>shift</l><l>lng</l><l>index</l></list></block><block collabId="item_1_359" s="doWarp"><script><block collabId="item_1_357" s="doSetVar"><l>text</l><custom-block collabId="item_1_355" s="word $arrowRight list %txt"><block collabId="item_1_354" var="text"/></custom-block></block><block collabId="item_1_353" s="doSetVar"><l>num</l><custom-block collabId="item_1_351" s="map %repRing over %mult%l"><block collabId="item_1_350" s="reifyReporter"><autolambda><block collabId="item_1_348" s="reportUnicode"><l></l></block></autolambda><list></list></block><list><block collabId="item_1_344" var="text"/></list></custom-block></block><block collabId="item_1_343" s="doSetVar"><l>index</l><l>1</l></block><block collabId="item_1_340" s="doSetVar"><l>lng</l><block collabId="item_1_338" s="reportListLength"><block collabId="item_1_337" var="shift list"/></block></block><custom-block collabId="item_1_336" s="for %upvar = %n to %n %cs"><l>i</l><l>1</l><block collabId="item_1_333" s="reportListLength"><block collabId="item_1_332" var="num"/></block><script><block collabId="item_1_330" s="doReplaceInList"><block collabId="item_1_329" var="i"/><block collabId="item_1_328" var="num"/><block collabId="item_1_327" s="reportSum"><block collabId="item_1_326" s="reportModulus"><block collabId="item_1_325" s="reportSum"><block collabId="item_1_324" s="reportListItem"><block collabId="item_1_323" var="i"/><block collabId="item_1_322" var="num"/></block><block collabId="item_1_321" s="reportDifference"><block collabId="item_1_320" s="reportListItem"><block collabId="item_1_319" var="index"/><block collabId="item_1_318" var="shift list"/></block><l>32</l></block></block><l>95</l></block><l>32</l></block></block><block collabId="item_1_314" s="doChangeVar"><l>index</l><l>1</l></block><block collabId="item_1_311" s="doIf"><block collabId="item_1_310" s="reportGreaterThan"><block collabId="item_1_309" var="index"/><block collabId="item_1_308" var="lng"/></block><script><block collabId="item_1_306" s="doSetVar"><l>index</l><l>1</l></block></script></block></script></custom-block><block collabId="item_1_303" s="doSetVar"><l>text</l><custom-block collabId="item_1_301" s="list $arrowRight word %l"><custom-block collabId="item_1_300" s="map %repRing over %mult%l"><block collabId="item_1_299" s="reifyReporter"><autolambda><block collabId="item_1_297" s="reportUnicodeAsLetter"><l></l></block></autolambda><list></list></block><list><block collabId="item_1_293" var="num"/></list></custom-block></custom-block></block><block collabId="item_1_292" s="doReport"><block collabId="item_1_291" var="text"/></block></script></block></script></block-definition><block-definition collabId="item_1_290" s="decrypt++ %&apos;encoded&apos; %&apos;shift list&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block collabId="item_1_283" s="doWarp"><script><block collabId="item_1_281" s="doSetVar"><l>shift list</l><custom-block collabId="item_1_279" s="map %repRing over %mult%l"><block collabId="item_1_278" s="reifyReporter"><autolambda><block collabId="item_1_276" s="reportDifference"><l>0</l><l></l></block></autolambda><list></list></block><list><block collabId="item_1_271" var="shift list"/></list></custom-block></block><block collabId="item_1_270" s="doReport"><custom-block collabId="item_1_269" s="encrypt++ %s %s"><block collabId="item_1_268" var="encoded"/><block collabId="item_1_267" var="shift list"/></custom-block></block></script></block></script></block-definition><block-definition collabId="item_1_266" s="map %&apos;function&apos; over %&apos;lists&apos;" type="reporter" category="lists"><header></header><code></code><inputs><input type="%repRing"></input><input type="%mult%l"></input></inputs><script><block collabId="item_1_259" s="doWarp"><script><block collabId="item_1_257" s="doDeclareVariables"><list><l>mapone</l><l>mapmany</l></list></block><block collabId="item_1_253" s="doSetVar"><l>mapone</l><block collabId="item_1_251" s="reifyScript"><script><block collabId="item_1_249" s="doIf"><custom-block collabId="item_1_248" s="empty? %l"><block collabId="item_1_247" var="data"/></custom-block><script><block collabId="item_1_245" s="doReport"><block collabId="item_1_244" s="reportNewList"><list></list></block></block></script></block><block collabId="item_1_242" s="doReport"><block collabId="item_1_241" s="reportCONS"><block collabId="item_1_240" s="evaluate"><block collabId="item_1_239" var="function"/><list><block collabId="item_1_237" s="reportListItem"><l>1</l><block collabId="item_1_235" var="data"/></block></list></block><block collabId="item_1_234" s="evaluate"><block collabId="item_1_233" var="mapone"/><list><block collabId="item_1_231" s="reportCDR"><block collabId="item_1_230" var="data"/></block></list></block></block></block></script><list><l>data</l></list></block></block><block collabId="item_1_227" s="doSetVar"><l>mapmany</l><block collabId="item_1_225" s="reifyScript"><script><block collabId="item_1_223" s="doIf"><custom-block collabId="item_1_222" s="empty? %l"><block collabId="item_1_221" s="reportListItem"><l>1</l><block collabId="item_1_219" var="data lists"/></block></custom-block><script><block collabId="item_1_217" s="doReport"><block collabId="item_1_216" s="reportNewList"><list></list></block></block></script></block><block collabId="item_1_214" s="doReport"><block collabId="item_1_213" s="reportCONS"><block collabId="item_1_212" s="evaluate"><block collabId="item_1_211" var="function"/><custom-block collabId="item_1_210" s="map %repRing over %mult%l"><block collabId="item_1_209" s="reifyReporter"><autolambda><block collabId="item_1_207" s="reportListItem"><l>1</l><l/></block></autolambda><list></list></block><list><block collabId="item_1_202" var="data lists"/></list></custom-block></block><block collabId="item_1_201" s="evaluate"><block collabId="item_1_200" var="mapmany"/><list><custom-block collabId="item_1_198" s="map %repRing over %mult%l"><block collabId="item_1_197" s="reifyReporter"><autolambda><block collabId="item_1_195" s="reportCDR"><l/></block></autolambda><list></list></block><list><block collabId="item_1_191" var="data lists"/></list></custom-block></list></block></block></block></script><list><l>data lists</l></list></block></block><block collabId="item_1_188" s="doIfElse"><custom-block collabId="item_1_187" s="empty? %l"><block collabId="item_1_186" s="reportCDR"><block collabId="item_1_185" var="lists"/></block></custom-block><script><block collabId="item_1_183" s="doReport"><block collabId="item_1_182" s="evaluate"><block collabId="item_1_181" var="mapone"/><list><block collabId="item_1_179" s="reportListItem"><l>1</l><block collabId="item_1_177" var="lists"/></block></list></block></block></script><script><block collabId="item_1_175" s="doReport"><block collabId="item_1_174" s="evaluate"><block collabId="item_1_173" var="mapmany"/><list><block collabId="item_1_171" var="lists"/></list></block></block></script></block></script></block></script></block-definition><block-definition collabId="item_1_170" s="empty? %&apos;data&apos;" type="predicate" category="lists"><header></header><code></code><inputs><input type="%l"></input></inputs><script><block collabId="item_1_164" s="doReport"><block collabId="item_1_163" s="reportEquals"><block collabId="item_1_162" var="data"/><block collabId="item_1_161" s="reportNewList"><list></list></block></block></block></script></block-definition><block-definition collabId="item_1_159" s="for %&apos;i&apos; = %&apos;start&apos; to %&apos;end&apos; %&apos;action&apos;" type="command" category="control"><header></header><code></code><inputs><input type="%upvar"></input><input type="%n">1</input><input type="%n">10</input><input type="%cs"></input></inputs><script><block collabId="item_1_150" s="doDeclareVariables"><list><l>step</l><l>tester</l></list></block><block collabId="item_1_146" s="doIfElse"><block collabId="item_1_145" s="reportGreaterThan"><block collabId="item_1_144" var="start"/><block collabId="item_1_143" var="end"/></block><script><block collabId="item_1_141" s="doSetVar"><l>step</l><l>-1</l></block><block collabId="item_1_138" s="doSetVar"><l>tester</l><block collabId="item_1_136" s="reifyReporter"><autolambda><block collabId="item_1_134" s="reportLessThan"><block collabId="item_1_133" var="i"/><block collabId="item_1_132" var="end"/></block></autolambda><list></list></block></block></script><script><block collabId="item_1_129" s="doSetVar"><l>step</l><l>1</l></block><block collabId="item_1_126" s="doSetVar"><l>tester</l><block collabId="item_1_124" s="reifyReporter"><autolambda><block collabId="item_1_122" s="reportGreaterThan"><block collabId="item_1_121" var="i"/><block collabId="item_1_120" var="end"/></block></autolambda><list></list></block></block></script></block><block collabId="item_1_118" s="doSetVar"><l>i</l><block collabId="item_1_116" var="start"/></block><block collabId="item_1_115" s="doUntil"><block collabId="item_1_114" s="evaluate"><block collabId="item_1_113" var="tester"/><list></list></block><script><block collabId="item_1_110" s="doRun"><block collabId="item_1_109" var="action"/><list></list></block><block collabId="item_1_107" s="doChangeVar"><l>i</l><block collabId="item_1_105" var="step"/></block></script></block></script></block-definition><block-definition collabId="item_1_104" s="join words %&apos;words&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%mult%txt"></input></inputs><script><block collabId="item_1_98" s="doWarp"><script><block collabId="item_1_96" s="doIf"><custom-block collabId="item_1_95" s="empty? %l"><block collabId="item_1_94" s="reportCDR"><block collabId="item_1_93" var="words"/></block></custom-block><script><block collabId="item_1_91" s="doReport"><block collabId="item_1_90" s="reportListItem"><l>1</l><block collabId="item_1_88" var="words"/></block></block></script></block><block collabId="item_1_87" s="doIf"><block collabId="item_1_86" s="reportEquals"><l></l><block collabId="item_1_84" s="reportListItem"><l>1</l><block collabId="item_1_82" var="words"/></block></block><script><block collabId="item_1_80" s="doReport"><custom-block collabId="item_1_79" s="join words %mult%txt"><block collabId="item_1_78" s="reportCDR"><block collabId="item_1_77" var="words"/></block></custom-block></block></script></block><block collabId="item_1_76" s="doIf"><block collabId="item_1_75" s="reportEquals"><l></l><block collabId="item_1_73" s="reportListItem"><l>2</l><block collabId="item_1_71" var="words"/></block></block><script><block collabId="item_1_69" s="doReport"><custom-block collabId="item_1_68" s="join words %mult%txt"><block collabId="item_1_67" s="reportCONS"><block collabId="item_1_66" s="reportListItem"><l>1</l><block collabId="item_1_64" var="words"/></block><block collabId="item_1_63" s="reportCDR"><block collabId="item_1_62" s="reportCDR"><block collabId="item_1_61" var="words"/></block></block></block></custom-block></block></script></block><block collabId="item_1_60" s="doReport"><block collabId="item_1_59" s="reportJoinWords"><list><block collabId="item_1_57" s="reportListItem"><l>1</l><block collabId="item_1_55" var="words"/></block><l> </l><custom-block collabId="item_1_53" s="join words %mult%txt"><block collabId="item_1_52" s="reportCDR"><block collabId="item_1_51" var="words"/></block></custom-block></list></block></block></script></block></script><scripts><script x="229.0000030000001" y="196.77778077777765"><block collabId="item_1_48" s="reportJoinWords"><list><l></l><l></l></list></block></script></scripts></block-definition><block-definition collabId="item_1_44" s="list $arrowRight sentence %&apos;data&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%l"></input></inputs><script><block collabId="item_1_38" s="doWarp"><script><block collabId="item_1_36" s="doReport"><custom-block collabId="item_1_35" s="join words %mult%txt"><block collabId="item_1_34" var="data"/></custom-block></block></script></block></script></block-definition><block-definition collabId="item_1_33" s="word $arrowRight list %&apos;word&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%txt"></input></inputs><script><block collabId="item_1_27" s="doWarp"><script><block collabId="item_1_25" s="doReport"><block collabId="item_1_24" s="reportTextSplit"><block collabId="item_1_23" var="word"/><l><option>letter</option></l></block></block></script></block></script></block-definition><block-definition collabId="item_1_20" s="list $arrowRight word %&apos;list&apos;" type="reporter" category="operators"><header></header><code></code><inputs><input type="%l"></input></inputs><script><block collabId="item_1_14" s="doWarp"><script><block collabId="item_1_12" s="doReport"><block collabId="item_1_11" s="reportJoinWords"><block collabId="item_1_10" var="list"/></block></block></script></block></script></block-definition><messageType><name>robot message</name><fields><field>robot</field><field>message</field></fields></messageType><messageType><name>robot command</name><fields><field>robot</field><field>command</field></fields></messageType></blocks>